---
layout:     post
title:      "BFS算法与DFS算法"
subtitle:   "BFS与DFS算法的白话解释"
date:       2016-07-24
author:     "MAI HAO"
header-img: "img/post-bg-js-module.jpg"
tags:
    - 算法
    - C/C++
---

### BFS

**广度优先搜索算法（Breadth-First-Search）**，又译作宽度优先搜索，或横向优先搜索，简称BFS，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和深度度优先搜索类似的思想。

已知图G=(V,E)和一个源顶点s，宽度优先搜索以一种系统的方式探寻G的边，从而“发现”s所能到达的所有顶点，并计算s到所有这些顶点的距离(最少边数)，该算法同时能生成一棵根为s且包括所有可达顶点的宽度优先树。对从s可达的任意顶点v，宽度优先树中从s到v的路径对应于图G中从s到v的最短路径，即包含最小边数的路径。该算法对有向图和无向图同样适用。

BFS之所以称之为宽度优先算法，是因为算法自始至终一直通过已找到和末找到顶点之间的边界向外扩展，就是说，算法首先搜索和s距离为k的所有顶点，然后再去搜索和s距离为k+l的其他顶点。

下图展示了BFS算法的整一个流程：
![BFS_jpg](/img/BFS_and_DFS/BFS_jpg.jpg)

> 由上图我们很容易就看得出来，其实就是以s为开始，先搜索到与s相邻的节点，接着再在这些节点中选其中一个找它的所有相邻节点。直到最后找到全部节点

### DFS

**深度优先搜索**所遵循的搜索策略是尽可能**“深”**地搜索图。在深度优先搜索中，对于最新发现的顶点，如果它还有以此为起点而未探测到的边，就沿此边继续汉下去。当结点v的所有边都己被探寻过，搜索将回溯到发现结点v有那条边的始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被发现为止。

下图展示了DFS算法的整一个流程：
![BFS_jpg](/img/BFS_and_DFS/DFS_jpg1.jpg)
![BFS_jpg](/img/BFS_and_DFS/DFS_jpg2.jpg)

> 由上图看出，每一次都是从源节点开始一路走到不能再走，然后开始回头，回头的时候如果有另外一条路也一路走下去，接着回头。